# Writing Scripts

Now you've learnt about Hubot Scripts you want to start getting stuck into
writing your own scripts. The goal of this book is to help more people
understand Hubot and how to write scripts for him.

## Getting Started

Earlier in the book you learnt about the shell adapter for Hubot. The shell
adapter is a development REPL for Hubot. It allows you to enter commands and
have Hubot respond.

For example the `ping` command from the `scripts/ping.coffee` file.

    Hubot> hubot ping
    Hubot> PONG
    Hubot>

Due to the asynchronous nature of Hubot, the REPL isn't that great, but it
works! You may notice some latency with commands that trigger a HTTP request or
long running task before displaying any output.

To exit the Hubot REPL you can type `exit`.

    Hubot> exit
    $

When you're creating scripts, even if you plan for them to remain private
(although this is discouraged if other people could find it useful) or
plan to contribute them to the Hubot Scripts repository, you can throw them into
the `scripts/` directory in your Hubot repository and have them automatically
loaded. This makes testing your script extremely easy.

## Hello World

For your first Hubot script we'll look at writing the simple "hello world"
example. The script will make Hubot respond with a greeting when someone says
hello to him. You'll expand this script throughout this chapter as you learn
more about the API surrounding Hubot scripts.

Create and open a `scripts/hello-world.coffee` in your text editor of choice and
we'll begin with looking at the simplest Hubot script. There are four ways Hubot
can "listen" for commands.

  * `robot.hear`
  * `robot.respond`
  * `robot.enter`
  * `robot.leave`

We'll look at using each of the above in simple examples.

### Hearing

Registering a command with `robot.hear` will trigger when your Hubot "hears" a
value that matches the given regular expression. Let's start with an example of
this. In your open file add the following code.

    module.exports = (robot) ->
      robot.hear /hello/i, (msg) ->
        msg.send "Hello"

As you can see this is fairly simple, so let's look at what each line is doing.
The first line is simply exporting an anonymous function that takes a `robot` as
an argument. This should be fairly obvious if you've had any experience using
Node.

The second line is where you're calling the `robot.hear` function with two
arguments, a regular expression that will match the string "hello" and a
callback function that has a `msg` argument.

The final line is the contents of the callback that we want to be called when
the regular expression is matched. In this example we're calling the `send`
function on the `msg` arugment which sends the specified text to the adapter and
displayed as though the Hubot user said it. So this example is Hubot saying
"Hello" when he sees someone else say "hello".

If you fire up the Hubot REPL using `bin/hubot` and try triggering the command.

    $ bin/hubot
    Hubot> hello
    Hubot> Hello
    Hubot> Oh hello there Hubot
    Hubot> Hello
    Hubot>

You will notice that Hubot will respond no matter where the "hello" is in the
text. This can be useful for certain things you wish to have Hubot to respond to
but doesn't really fit this script. Which brings us onto the next method of
triggering Hubot, responding.

## Responding

Registering a command with `robot.respond`, will trigger when you direct a
command at Hubot prefixed with his specified name. Let's expand the above
example to use `robot.respond` instead.

    module.exports = (robot) ->
      robot.respond /hello/i, (msg) ->
        msg.reply "Hello"

The first line hasn't changed and is the same as the above example. We've
changed the second line to use `respond` instead of `hear`. The final line we
changed `send` to `reply` so we can look at a different way of having Hubot send
messages to the adapter. The `reply` function is send the message back prefixed
the user name of the user who addressed Hubot.

    $ bin/hubot
    Hubot> hubot hello
    Hubot> Shell: Hello
    Hubot> @hubot hello
    Hubot> Shell: Hello
    Hubot>

You may be wondering where the name "Shell" came from. In the REPL there are no
users so there is a "default" user which has the name "Shell".

So you're not a fan of greeting people with "Hello"? You're more of a "Howdy" or
"Good day" type of person? Okay, then let's look at making Hubot match different
greetings without adding multiple commands.

As the first arguments of the `hear` and `respond` functions is a regular
expression, we can build up a regular expression that can match different forms
of greeting, then have Hubot respond with the one which is used.

    module.exports = (robot) ->
      robot.respond /(hello|hey|howdy|good day)/i, (msg) ->
        msg.reply msg.match[1]

This change will now make Hubot respond to any of the following forms for
greeting.

  * Hello
  * Hey
  * Howdy
  * Good day

The `msg` argument will have a `match` property that is an array of any regular
expression group matches. The first item will be the entire string that is
matched, with the remaining items being the groups matched in the regular
expression.

Now if you fire up the Hubot REPL and try addressing your Hubot with different
greetings you will see Hubot respnd with the matching greeting.

    $ bin/hubot
    Hubot> hubot hello
    Hubot> Shell: hello
    Hubot> hubot hey
    Hubot> Shell: hey
    Hubot>

The final two methods of Hubot triggering commands are `enter` and `leaving`.
These will trigger when the adapter triggers an `enter` or `leave` message. They
won't work with the Hubot REPL, so I shall leave it as an exercise for you to
change the above script into one that will greet a user when they enter a room
that Hubot is in.
